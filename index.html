<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Well Trajectory Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .control-panel {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .upload-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .chart-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        .chart-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
            position: relative;
        }
        canvas {
            width: 100% !important;
            height: 300px !important;
            touch-action: none; /* For zoom/pan */
        }
        button, select {
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            background: #007BFF;
            color: white;
            border: none;
        }
        button:hover {
            background: #0056b3;
        }
        select {
            border: 1px solid #ddd;
            background: white;
        }
        .unit-selection {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Well Trajectory Data Visualization</h1>
        
        <div class="upload-section">
            <h2>Upload Well Survey Data</h2>
            <div class="control-panel">
                <div>
                    <input type="file" id="fileInput" accept=".txt,.csv,.las">
                    <button onclick="parseFile()">Load & Plot Data</button>
                    <button onclick="exportCharts()">Export All Charts</button>
                </div>
                <div class="unit-selection">
                    <label for="unitSelect">MD Units:</label>
                    <select id="unitSelect" onchange="updateUnits()">
                        <option value="ft">Feet (ft)</option>
                        <option value="m">Meters (m)</option>
                    </select>
                </div>
            </div>
            <p>File format: <strong>MD (Measured Depth), INC (Inclination), AZI (Azimuth)</strong> in columns (CSV, LAS, or space-separated).</p>
        </div>

        <div class="chart-container">
            <div class="chart-wrapper" style="background-color: #f0f8ff;">
                <h3>MD vs Inclination (INC)</h3>
                <canvas id="incChart"></canvas>
                <div class="tooltip" id="incTooltip"></div>
            </div>
            <div class="chart-wrapper" style="background-color: #f0fff0;">
                <h3>MD vs Azimuth (AZI)</h3>
                <canvas id="aziChart"></canvas>
                <div class="tooltip" id="aziTooltip"></div>
            </div>
            <div class="chart-wrapper" style="background-color: #fff0f5;">
                <h3>MD vs True Vertical Depth (TVD)</h3>
                <canvas id="tvdChart"></canvas>
                <div class="tooltip" id="tvdTooltip"></div>
            </div>
            <div class="chart-wrapper" style="background-color: #f5f0ff;">
                <h3>MD vs Delta Inclination (ΔINC)</h3>
                <canvas id="deltaIncChart"></canvas>
                <div class="tooltip" id="deltaIncTooltip"></div>
            </div>
            <div class="chart-wrapper" style="background-color: #fff8f0;">
                <h3>MD vs Delta Azimuth (ΔAZI)</h3>
                <canvas id="deltaAziChart"></canvas>
                <div class="tooltip" id="deltaAziTooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let surveyData = [];
        let currentUnits = 'ft';
        const FT_TO_M = 0.3048;

        // Parse uploaded file
        function parseFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert("Please select a file first!");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                surveyData = parseWellData(content, file.name);
                
                if (surveyData.length > 0) {
                    processData();
                    drawCharts();
                } else {
                    alert("No valid data found in the file!");
                }
            };
            reader.readAsText(file);
        }

        // Parse different file formats
        function parseWellData(content, filename) {
            const lines = content.split('\n');
            const data = [];
            let isLAS = filename.toLowerCase().endsWith('.las');
            let inDataSection = false;
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                // LAS file parsing
                if (isLAS) {
                    if (line.startsWith('~A')) inDataSection = true;
                    if (!inDataSection) continue;
                    if (line.startsWith('~')) break; // End of data section
                }
                
                // Split by comma (CSV) or whitespace
                const parts = line.split(/[, \t]+/).filter(part => part !== '');
                
                if (parts.length >= 3) {
                    const md = parseFloat(parts[0]);
                    const inc = parseFloat(parts[1]);
                    const azi = parseFloat(parts[2]);
                    
                    if (!isNaN(md) && !isNaN(inc) && !isNaN(azi)) {
                        data.push({ md, inc, azi });
                    }
                }
            }
            return data;
        }

        // Process survey data
        function processData() {
            // Convert MD to meters for internal calculations
            surveyData.forEach(point => {
                point.md_meters = currentUnits === 'ft' ? point.md * FT_TO_M : point.md;
            });

            // Calculate TVD using minimum curvature
            let tvd_meters = 0;
            for (let i = 0; i < surveyData.length; i++) {
                if (i === 0) {
                    surveyData[i].tvd_meters = 0;
                } else {
                    const deltaMD = surveyData[i].md_meters - surveyData[i-1].md_meters;
                    const avgInc = (surveyData[i].inc + surveyData[i-1].inc) / 2 * Math.PI / 180;
                    tvd_meters += deltaMD * Math.cos(avgInc);
                    surveyData[i].tvd_meters = tvd_meters;
                }
            }

            // Calculate Delta INC and Delta AZI
            for (let i = 0; i < surveyData.length; i++) {
                if (i === 0) {
                    surveyData[i].deltaInc = 0;
                    surveyData[i].deltaAzi = 0;
                } else {
                    surveyData[i].deltaInc = surveyData[i].inc - surveyData[i-1].inc;
                    surveyData[i].deltaAzi = surveyData[i].azi - surveyData[i-1].azi;
                }
            }
        }

        // Update units and redraw
        function updateUnits() {
            currentUnits = document.getElementById('unitSelect').value;
            if (surveyData.length > 0) {
                drawCharts();
            }
        }

        // Convert internal meters to display units
        function getDisplayMD(md_meters) {
            return currentUnits === 'ft' ? md_meters / FT_TO_M : md_meters;
        }

        // Draw all charts
        function drawCharts() {
            const mdLabel = `MD (${currentUnits})`;
            drawChart('incChart', 'Inclination (deg)', surveyData.map(d => d.inc), '#43a047', mdLabel, 'incTooltip');
            drawChart('aziChart', 'Azimuth (deg)', surveyData.map(d => d.azi), '#1e88e5', mdLabel, 'aziTooltip');
            drawChart('tvdChart', `TVD (${currentUnits})`, surveyData.map(d => getDisplayMD(d.tvd_meters)), '#e53935', mdLabel, 'tvdTooltip');
            drawChart('deltaIncChart', 'Δ Inclination (deg)', surveyData.map(d => d.deltaInc), '#fb8c00', mdLabel, 'deltaIncTooltip');
            drawChart('deltaAziChart', 'Δ Azimuth (deg)', surveyData.map(d => d.deltaAzi), '#8e24aa', mdLabel, 'deltaAziTooltip');
        }

        // Draw individual chart
        function drawChart(canvasId, yLabel, yData, lineColor, xLabel, tooltipId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById(tooltipId);
            
            // Set canvas dimensions
            canvas.width = canvas.parentElement.clientWidth - 40;
            canvas.height = 300;

            // Clear previous chart
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const padding = 40;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Find min/max for scaling
            const mdValues = surveyData.map(d => getDisplayMD(d.md_meters));
            const minMD = Math.min(...mdValues);
            const maxMD = Math.max(...mdValues);
            const minY = Math.min(...yData);
            const maxY = Math.max(...yData);

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines (MD)
            const mdStep = niceIncrement((maxMD - minMD) / 10);
            for (let md = Math.floor(minMD/mdStep)*mdStep; md <= maxMD; md += mdStep) {
                const x = padding + ((md - minMD) / (maxMD - minMD)) * width;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
                
                // X-axis labels
                ctx.fillStyle = '#555';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(md.toFixed(1), x, canvas.height - 10);
            }

            // Horizontal grid lines (Y-axis)
            const yStep = niceIncrement((maxY - minY) / 5);
            for (let yVal = Math.floor(minY/yStep)*yStep; yVal <= maxY; yVal += yStep) {
                const y = canvas.height - padding - ((yVal - minY) / (maxY - minY)) * height;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
                
                // Y-axis labels
                ctx.fillStyle = '#555';
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(yVal.toFixed(1), padding - 5, y + 4);
            }

            // Draw axes
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, canvas.width / 2, canvas.height - 10);
            
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            // Draw data line
            ctx.beginPath();
            for (let i = 0; i < surveyData.length; i++) {
                const displayMD = getDisplayMD(surveyData[i].md_meters);
                const x = padding + ((displayMD - minMD) / (maxMD - minMD)) * width;
                const y = canvas.height - padding - ((yData[i] - minY) / (maxY - minY)) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw data points
            ctx.fillStyle = lineColor;
            for (let i = 0; i < surveyData.length; i++) {
                const displayMD = getDisplayMD(surveyData[i].md_meters);
                const x = padding + ((displayMD - minMD) / (maxMD - minMD)) * width;
                const y = canvas.height - padding - ((yData[i] - minY) / (maxY - minY)) * height;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add tooltip interaction
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find closest data point
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < surveyData.length; i++) {
                    const displayMD = getDisplayMD(surveyData[i].md_meters);
                    const pointX = padding + ((displayMD - minMD) / (maxMD - minMD)) * width;
                    const pointY = canvas.height - padding - ((yData[i] - minY) / (maxY - minY)) * height;
                    const distance = Math.sqrt(Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                // Show tooltip if close to a point
                if (minDistance < 20) {
                    const displayMD = getDisplayMD(surveyData[closestIndex].md_meters);
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY - 30}px`;
                    tooltip.innerHTML = `
                        <div>MD: ${displayMD.toFixed(2)} ${currentUnits}</div>
                        <div>${yLabel}: ${yData[closestIndex].toFixed(2)}</div>
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            canvas.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });

            // Add zoom/pan (basic implementation)
            let zoom = 1, pan = 0;
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom += e.deltaY * -0.01;
                zoom = Math.min(Math.max(0.5, zoom), 5);
                drawCharts(); // Simplified - would need more complex handling
            });
        }

        // Export charts as PNG
        function exportCharts() {
            const chartIds = ['incChart', 'aziChart', 'tvdChart', 'deltaIncChart', 'deltaAziChart'];
            chartIds.forEach(id => {
                const canvas = document.getElementById(id);
                const link = document.createElement('a');
                link.download = `${id}_well_data.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }

        // Helper function for nice axis increments
        function niceIncrement(range) {
            const exponent = Math.floor(Math.log10(range));
            const fraction = range / Math.pow(10, exponent);
            let niceFraction = 1;
            if (fraction <= 1.5) niceFraction = 1;
            else if (fraction <= 3) niceFraction = 2;
            else if (fraction <= 7) niceFraction = 5;
            else niceFraction = 10;
            return niceFraction * Math.pow(10, exponent);
        }
    </script>
</body>
</html>
